import copy
import inspect
from typing import Any, ClassVar, Dict, Optional, Union

from django.core.exceptions import ImproperlyConfigured
from django.template.base import Template
from django.template.context import Context
from django.template.loader import get_template

from django_viewcomponent.component_registry import (  # NOQA
    AlreadyRegistered,
    ComponentRegistry,
    NotRegistered,
    register,
    registry,
)
from django_viewcomponent.fields import BaseSlotField


class Component:
    template_name: ClassVar[Optional[str]] = None
    template: ClassVar[Optional[str]] = None

    # if pass HTML to the component without calling slot fields, it will be stored here
    # and you can get it using self.content
    content = ""

    # the variable name of the component in the context
    component_target_var = None

    # the context of the component, generated by get_context_data
    component_context: Context = Context({})

    def __init__(self, *args, **kwargs):
        pass

    def __init_subclass__(cls, **kwargs):
        cls.class_hash = hash(inspect.getfile(cls) + cls.__name__)

    def get_context_data(self, **kwargs) -> Context:
        self.component_context["self"] = self
        if self.component_target_var:
            self.component_context[self.component_target_var] = self
        return self.component_context

    def get_template_name(self) -> Optional[str]:
        return self.template_name

    def get_template_string(self) -> Optional[str]:
        return self.template

    def get_template(self) -> Template:
        template_string = self.get_template_string()
        if template_string is not None:
            return Template(template_string)

        template_name = self.get_template_name()
        if template_name is not None:
            return get_template(template_name).template

        raise ImproperlyConfigured(
            f"Either 'template_name' or 'template' must be set for Component {type(self).__name__}."
            f"Note: this attribute is not required if you are overriding the class's `get_template*()` methods.",
        )

    def prepare_context(
        self,
        context_data: Union[Dict[str, Any], Context, None] = None,
    ) -> Context:
        """
        Prepare the context data for rendering the component.

        https://docs.djangoproject.com/en/5.1/ref/templates/api/#django.template.Template.render
        """
        context_data = context_data or {}
        if isinstance(context_data, dict):
            context = Context(context_data)
        else:
            context = context_data

        return context

    def render(
        self,
        context_data: Union[Dict[str, Any], Context, None] = None,
    ) -> str:
        template = self.get_template()
        return template.render(self.prepare_context(context_data))

    def render_from_parent_context(self, parent_context=None):
        """
        If developers build components in Python code, then slot fields can be ignored, this method
        help simplify rendering the child components

        Div(
            Fieldset(
                "Basic Info",
                Field('first_name'),
                Field('last_name'),
                Field('email'),
                css_class='fieldset',
            ),
            Submit('Submit'),
            dom_id="main",
        )
        """
        parent_context = parent_context or {}
        self.component_context = self.prepare_context(parent_context)
        with self.component_context.push():
            updated_context = self.get_context_data()
            return self.render(updated_context)

    def check_slot_fields(self):
        # check required slot fields
        for key in self._rendered_fields_dict().keys():
            field = getattr(self, key)
            if field.required and not field.filled:
                raise ValueError(f"Field {key} is required")

    @classmethod
    def _rendered_fields_dict(cls):
        """
        Get slot fields from the Component class fields
        """
        rendered_fields_dict = {}
        for field_name in dir(cls):
            field = getattr(cls, field_name)
            if isinstance(field, BaseSlotField):
                rendered_fields_dict[field_name] = field
        return rendered_fields_dict

    def create_slot_fields(self):
        slot_fields = self._rendered_fields_dict()
        for field_name, field in slot_fields.items():
            new_field = copy.deepcopy(field)
            new_field.parent_component = self
            setattr(self, field_name, new_field)
