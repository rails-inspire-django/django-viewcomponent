import copy
import inspect
from typing import Any, ClassVar, Dict, Optional, Union

from django.core.exceptions import ImproperlyConfigured
from django.template.base import Template
from django.template.context import Context
from django.template.loader import get_template

from django_viewcomponent.component_registry import (  # NOQA
    AlreadyRegistered,
    ComponentRegistry,
    NotRegistered,
    register,
    registry,
)
from django_viewcomponent.fields import BaseSlotField


class Component:
    template_name: ClassVar[Optional[str]] = None
    template: ClassVar[Optional[str]] = None

    # if pass HTML to the component without fill tags, it will be stored here
    # and you can get it using self.content
    content = ""

    # the name of the component
    component_name = None

    # the variable name of the component in the context
    component_target_var = None

    # the context of the component, generated by get_context_data
    component_context: Dict["str", Any] = {}

    # the context of the outer
    outer_context: Dict["str", Any] = {}

    def __init__(self, *args, **kwargs):
        pass

    def __init_subclass__(cls, **kwargs):
        cls.class_hash = hash(inspect.getfile(cls) + cls.__name__)

    def get_context_data(self, **kwargs) -> Dict[str, Any]:
        # inspired by rails viewcomponent before_render method
        # developers can add extra context data by overriding this method
        self.outer_context["self"] = self
        if self.component_target_var:
            self.outer_context[self.component_target_var] = self
        return self.outer_context

    def get_template_name(self) -> Optional[str]:
        return self.template_name

    def get_template_string(self) -> Optional[str]:
        return self.template

    def get_template(self) -> Template:
        template_string = self.get_template_string()
        if template_string is not None:
            return Template(template_string)

        template_name = self.get_template_name()
        if template_name is not None:
            return get_template(template_name).template

        raise ImproperlyConfigured(
            f"Either 'template_name' or 'template' must be set for Component {type(self).__name__}."
            f"Note: this attribute is not required if you are overriding the class's `get_template*()` methods."
        )

    def render(
        self,
        context_data: Union[Dict[str, Any], Context, None] = None,
    ) -> str:
        context_data = context_data or {}
        if isinstance(context_data, dict):
            context = Context(context_data)
        else:
            context = context_data

        template = self.get_template()
        return template.render(context)

    def check_slot_fields(self):
        # check required slot fields
        for key in self._rendered_fields_dict().keys():
            field = getattr(self, key)
            if field.required and not field.filled:
                raise ValueError(f"Field {key} is required")

    @classmethod
    def _rendered_fields_dict(cls):
        """
        Get slot fields from the Component class fields
        """
        rendered_fields_dict = {}
        for field_name in dir(cls):
            field = getattr(cls, field_name)
            if isinstance(field, BaseSlotField):
                rendered_fields_dict[field_name] = field
        return rendered_fields_dict

    def create_slot_fields(self):
        slot_fields = self._rendered_fields_dict()
        for field_name, field in slot_fields.items():
            new_field = copy.deepcopy(field)
            new_field.parent_component = self
            setattr(self, field_name, new_field)
